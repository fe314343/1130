<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<!-- 設定 viewport 確保網頁在移動裝置上能正確縮放 -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>聖訓小卡生成</title>

<!-- 載入 html-to-image 函式庫，用於將 HTML 元素轉換為圖片 (DOM 截圖) -->
<script src="https://cdn.jsdelivr.net/npm/html-to-image@1.11.12/dist/html-to-image.min.js"></script>
<!-- 載入 JSZip 函式庫，用於將多個圖片打包成一個 ZIP 壓縮檔 -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<!-- 載入 FileSaver.js 函式庫，用於在瀏覽器端觸發檔案下載流程 -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>

<!-- 引入 Google Fonts 的 Noto Serif TC (思源宋體 繁體中文)，作為標楷體的備用字體 -->
<link href="https://fonts.googleapis.com/css2?family=Noto+Serif+TC:wght%40400%3B700&display=swap" rel="stylesheet" crossorigin="anonymous">

<style>
/* ---------------------------------------------------- */
/* ★ 全域樣式設定 (Global Styles) ★                        */
/* ---------------------------------------------------- */
body {
    /* 字體設定：優先使用使用者系統內建的「標楷體」或其常見別名，以符合書寫風格。
       如果都找不到，則使用思源宋體 (Noto Serif TC)。 */
    font-family: "標楷體", "DFKai-SB", "KaiTi", 'Noto Serif TC', serif;
    background-color: #f0f0f0; /* 頁面背景色 */
    margin: 0; padding: 20px; /* 頁面邊距 */
    display: flex; /* 使用 Flexbox 進行佈局 */
    flex-direction: column; /* 垂直排列子元素 */
    align-items: center; /* 水平居中對齊 */
    min-height: 100vh; /* 確保內容區塊至少佔滿整個視窗高度 */
}
.main-container {
    width: 90%; max-width: 1200px; /* 設定最大寬度並居中 */
    padding: 20px;
    background: #fff; /* 白色背景 */
    border-radius: 12px; /* 圓角邊框 */
    box-shadow: 0 4px 15px rgba(0,0,0,0.15); /* 陰影效果 */
}
#controls {
    display: flex; gap: 15px; /* 控制項間距 */
    margin-bottom: 15px;
    flex-wrap: wrap; /* 允許控制項在小螢幕上換行 */
}
.control-group { display: flex; flex-direction: column; } /* 控制項分組，垂直排列 Label 和 Select */
/* 下拉選單和按鈕的基礎樣式 */
select, button {
    padding: 8px 10px;
    font-size: 1rem;
    border-radius: 5px;
    border: 1px solid #ccc;
    cursor: pointer;
    transition: background-color 0.3s;
    font-family: inherit; /* 繼承 body 的字體設定，確保中文字體一致 */
}
.action-buttons {
    display: flex;
    gap: 15px;
    align-items: flex-end; /* 底部對齊，讓按鈕與下拉選單的底部對齊 */
}
#resultsContainer {
    display: flex; gap: 20px;
    overflow-x: auto; /* 允許水平滾動查看所有生成的圖片預覽 */
    padding: 10px 0;
    min-height: 500px; /* 確保結果容器有足夠高度，避免內容跳動 */
}

/* ---------------------------------------------------- */
/* ★ 直式圖檔生成區塊樣式 (截圖目標: .result-item) ★        */
/* ---------------------------------------------------- */
.result-item {
    /* 固定的圖片尺寸：720x1280 像素，常見的直式手機螢幕比例，這是截圖的邊界 */
    width: 720px;
    height: 1280px;
    min-width: 720px;
    min-height: 1280px;
    position: relative; /* 設置相對定位，以容納絕對定位的文字和圖片 */
    box-sizing: border-box; /* 確保 padding/border 不會增加總尺寸 */
    border: none; 
    border-radius: 0;
    overflow: hidden; /* 確保內容在截圖邊界內 */
}

/* 背景圖片樣式 */
.result-img {
    width: 100%;
    height: 100%;
    object-fit: contain; /* 確保圖片不變形地適應容器 */
    position: absolute;
    top: 0; left: 0;
    z-index: 1; /* 位於下層，作為背景 */
}

/* 文字內容區塊 - 實作直式書寫 */
.content-block {
    position: absolute;
    z-index: 2; /* 位於上層，覆蓋背景圖片 */

    /* 調整定位：直式書寫從右側開始，稍微從邊緣內縮 */
    top: 40px; 
    right: 5px; 

    height: calc(100% - 50px); /* 垂直方向的長度（即字行的高度） */
    width: calc(100% - 10px); /* 水平方向的寬度（即字行數量的空間） */
    overflow: hidden; /* 防止文字溢出容器 */

    /* ★ 核心：設定直式書寫模式（從右向左，即列從右邊開始排） */
    writing-mode: vertical-rl;
    /* 確保所有字元（包括數字和英文字母）都保持直立，不旋轉 90 度 */
    text-orientation: upright;
    
    font-family: "標楷體", "DFKai-SB", "KaiTi", 'Noto Serif TC', serif;
    font-size: 32px; /* 基礎字體大小 */
    line-height: 1.2; /* 行距 (控制字行之間的垂直距離) */
    letter-spacing: 10px; /* 基礎字元間距 (控制字元間的水平距離) */
    white-space: pre-wrap; /* 允許文字保留原始換行符 (\n) 且自動換行 */
    word-break: break-word; /* 允許長單詞或連續字符在任何位置斷開 */

    color: #333;
    /* 輕微的文字陰影，讓文字在複雜背景圖片上更清晰，增強可讀性 */
    text-shadow: 0 0 3px rgba(255,255,255,0.9), 0 0 1px rgba(0,0,0,0.2); 
}

/* 區域文字的樣式：字體較小 */
.small-text {
    font-size: 20px;
    font-family: "標楷體", "DFKai-SB", "KaiTi", 'Noto Serif TC', serif;
}

/* 專門用於對齊的 span 元素，需要設定 display: inline-block 才能應用 letter-spacing */
/* 這是實現標題兩行文字「長度一致」對齊的核心 CSS 元素 */
.content-block span {
    display: inline-block;
}

/* 下載按鈕的樣式和定位 */
.download-button-wrapper {
    position: absolute;
    bottom: 10px;
    left: 10px;
    z-index: 5; /* 確保按鈕在最上層 */
    writing-mode: horizontal-tb; /* 確保按鈕文字是橫式，不被直式書寫影響 */
}

/* (其他按鈕樣式保持不變...) */
.btn-style {
    background-color: #4CAF50; /* 按鈕基本顏色 */
    color: white;
    padding: 8px 12px;
    border: none;
    border-radius: 5px;
    cursor: pointer;
}
.btn-style:hover {
    background-color: #45a049;
}
/* 下載全部按鈕的特殊樣式 */
#downloadAllBtn {
    background-color: #007bff;
    color: white;
    padding: 10px 15px;
}
#downloadAllBtn:hover {
    background-color: #0056b3;
}
#downloadAllBtn:disabled {
    background-color: #cccccc;
    cursor: not-allowed;
}

/* 媒體查詢：適應手機螢幕，將預覽圖縮小 */
@media (max-width: 768px) {
    .result-item {
        width: 300px;
        height: 400px;
    }
}
</style>
</head>
<body>

<div class="main-container">
    <h1 style="text-align:center; margin-bottom:10px;">聖訓小卡生成</h1>

    <div id="controls">
        <div class="control-group">
            <label>選擇欄位:</label>
            <select id="filterField">
                <option value="班期">班期</option>
                <option value="日期">日期</option>
                <option value="仙佛">仙佛</option>
                <option value="姓名">姓名</option>
                <option value="內容">內容</option>
                <option value="區域">區域</option>
            </select>
        </div>

        <div class="control-group">
            <label>選擇值:</label>
            <!-- 預設禁用，等資料載入後啟用 -->
            <select id="filterValueSelect" disabled>
                <option value="">請先選欄位</option>
            </select>
        </div>

        <div class="action-buttons">
            <button class="btn-style" onclick="applyFilter()">開始篩選</button>
            <!-- 下載所有圖片為 ZIP 檔案的按鈕 -->
            <button id="downloadAllBtn" class="btn-style" onclick="downloadAllImages()" disabled>下載為 ZIP</button>
        </div>
    </div>

    <!-- 用於顯示系統訊息或錯誤提示 -->
    <div id="messageBox" style="margin-bottom: 10px;"></div>
    <!-- 圖片結果預覽的容器 -->
    <div id="resultsContainer"><p>請選擇篩選條件後點擊開始篩選。</p></div>
</div>

<script>
// ----------------------------------------------------
// ★ JavaScript 核心邏輯 ★
// ----------------------------------------------------

// Google Apps Script 部署的 URL，用於從 Google Sheets 獲取 JSON 資料
const GS_SCRIPT_URL = 'https://script.google.com/macros/s/AKfycbzPsok1XF4E4PQEmckvxK3pY8GPI1GeTrceC5Oz5deQbDMvmgtJxd1e-WcIV4GjgxZV3g/exec';

// 欄位名稱映射表，用於從下拉選單的值對應到 JSON 資料的鍵
const fieldMap = {
    "班期":"班期","日期":"日期","仙佛":"仙佛",
    "姓名":"姓名","內容":"內容","區域":"區域"
};

let globalSheetData = null; // 儲存從試算表載入的所有資料
let downloadableItems = []; // 儲存所有待下載的圖片元素和檔名資訊
// 獲取 DOM 元素實例，方便後續操作
const messageBox = document.getElementById('messageBox');
const resultsContainer = document.getElementById('resultsContainer');
const downloadAllBtn = document.getElementById('downloadAllBtn');

// ★ 字元對齊和間距相關常數 - 這是直式標題對齊的核心 ★
const CHAR_FONT_SIZE_PX = 34; // 內容區塊的字體大小 (用於計算視覺空間)
const BASE_LETTER_SPACING_PX = 10; // CSS 中 .content-block 設定的基礎字距
// 一個字元在直式書寫中佔用的視覺空間 (字體大小 + 基礎字距)
const VISUAL_CHAR_UNIT_PX = CHAR_FONT_SIZE_PX + BASE_LETTER_SPACING_PX; // 44px
const ALIGN_MIN_TARGET_LEN = 15; // 當兩行標題都太短時，預設對齊的最小目標長度


/**
 * 顯示訊息給使用者
 * @param {string} msg 訊息內容
 * @param {boolean} isError 是否為錯誤訊息 (決定顏色)
 */
function displayMessage(msg, isError=false){
    messageBox.textContent = msg;
    // 根據是否為錯誤來設定訊息顏色
    messageBox.style.color = isError ? 'red':'green';
}
// 清除訊息
function hideMessage(){ messageBox.textContent=''; }

/**
 * 針對直式書寫強制斷行，防止內容超出單行垂直空間 (圖片的高度)。
 * @param {string} text 原始文字
 * @param {number} maxCharsPerLine 每行最大字數 (根據 1280px 高度估算，調整此值可改變每列的字數)
 * @returns {string} 處理後的帶有換行符的文字
 */
function forceVerticalLineBreak(text, maxCharsPerLine=21) { 
    if (!text) return '';
    // 將輸入文字按原始換行符 (\n) 分割成行
    const originalLines = text.split('\n');
    let processedLines = [];
    
    for (const line of originalLines) {
        if (line.length > maxCharsPerLine) {
            let tempLine = '';
            let lineChunks = [];
            // 逐字檢查，如果達到最大長度則強制換行
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                if (tempLine.length === maxCharsPerLine) {
                    lineChunks.push(tempLine); // 推入已滿的一行
                    tempLine = char; // 將當前字元作為新行的開頭
                } else {
                    tempLine += char;
                }
            }
            if (tempLine.length > 0) lineChunks.push(tempLine); // 推入最後一行
            // 將過長的行以換行符 (\n) 串接，使其在直式書寫中換到下一列
            processedLines.push(lineChunks.join('\n'));
        } else {
            // 不足長度的行保持不變
            processedLines.push(line);
        }
    }
    // 將所有行以換行符串接回單一字串
    return processedLines.join('\n');
}

/**
 * 根據最長行調整字元間距，以達到視覺上的垂直對齊 (長度一致)。
 * @param {string} text 要調整的文字內容 (日期或仙佛行)。
 * @param {number} targetLen 目標長度 (字元數)。
 * @returns {string} 包含 inline style 的 <span> HTML 字串或原始文字。
 */
function generateAlignedSpan(text, targetLen) {
    if (!text || text.trim().length === 0) return text;
    const currentLen = text.length;

    // 判斷是否需要進行間距擴展
    if (currentLen >= targetLen) {
        return text; // 長度足夠或超過目標，直接回傳原始文字
    }

    // 計算需要補足多少個「字元單位」的長度 (即字元差)
    const neededCharUnits = targetLen - currentLen;
    // 計算總共需要的額外像素空間 (字元差 * 每個字元的視覺單位)
    const totalExtraSpaceNeededPx = neededCharUnits * VISUAL_CHAR_UNIT_PX;
    
    const numGaps = currentLen - 1; // 間隙數量 = 字數 - 1 (n個字有n-1個間隙)

    let finalSpan = text;

    if (numGaps > 0) {
        // 將總額外空間平均分配到每個間隙中
        const extraSpacingPerGap = totalExtraSpaceNeededPx / numGaps;
        // 新的 letter-spacing = 基礎間距 (10px) + 每個間隙的額外間距
        const totalSpacing = BASE_LETTER_SPACING_PX + extraSpacingPerGap;
        
        // 將文字包裝在 span 內，並應用計算出的 letter-spacing
        finalSpan = `<span style="letter-spacing:${totalSpacing.toFixed(2)}px;">${text}</span>`;
    } else if (currentLen === 1) {
        // 如果只有一個字，無法調整間距 (numGaps=0)，改為用全形空白補足長度
        finalSpan = text + '　'.repeat(neededCharUnits); 
    }
    
    return finalSpan;
}


/**
 * 異步獲取試算表資料，並更新 UI 狀態
 */
async function fetchSheetData(){
    const selectElement = document.getElementById('filterValueSelect');
    // 顯示載入狀態
    selectElement.innerHTML = '<option>載入中...</option>';
    selectElement.disabled = true;
    resultsContainer.innerHTML = '<p>資料載入中，請稍候...</p>';
    hideMessage();
    try {
        // 使用 fetch 發送 HTTP 請求獲取 JSON 資料
        const res = await fetch(GS_SCRIPT_URL);
        const data = await res.json();
        globalSheetData = data; // 儲存全域資料
        displayMessage('資料載入成功');
        return data;
    } catch (e) {
        console.error('Fetch error:', e);
        displayMessage('資料載入失敗',true);
        return null;
    }
}

/**
 * 根據選定的欄位填充篩選值下拉選單
 * @param {Array<Object>} data 試算表資料
 * @param {string} fieldKey 欄位名稱
 */
function populateFilterValues(data, fieldKey){
    const selectElement = document.getElementById('filterValueSelect');
    selectElement.innerHTML = '';
    
    if (!data || data.length === 0){
        selectElement.disabled=true;
        return;
    }

    // 使用 Set 確保篩選值不重複
    const uniqueValues = new Set();
    data.forEach(row=>{
        const val = row[fieldKey];
        if(val) uniqueValues.add(val.toString().trim());
    });
    
    // 按中文排序 (使用 localeCompare 搭配 'zh-TW' 參數確保正確的中文排序)
    const sorted = Array.from(uniqueValues).sort((a,b)=>a.localeCompare(b,'zh-TW'));

    // 增加預設選項
    const def = document.createElement('option');
    def.value=''; def.textContent='--- 請選擇 ---';
    selectElement.appendChild(def);

    // 填充所有唯一值到下拉選單
    sorted.forEach(v=>{
        const o=document.createElement('option');
        o.value=v; o.textContent=v;
        selectElement.appendChild(o);
    });

    selectElement.disabled=false; // 載入完成後啟用下拉選單
}

// 頁面載入後初始化
document.addEventListener('DOMContentLoaded', async()=>{
    const initializeData = async () => {
        // 如果資料未載入，則從遠端獲取
        if(!globalSheetData) await fetchSheetData();
        // 預設填充「班期」的篩選值
        if (globalSheetData) {
            populateFilterValues(globalSheetData, fieldMap["班期"]);
        }
    };

    await initializeData();
    
    // 監聽篩選欄位變更，當使用者切換欄位時，重新填充對應的篩選值
    document.getElementById('filterField').addEventListener('change', (event)=>{ 
        populateFilterValues(globalSheetData, fieldMap[event.target.value]);
    });
});

/**
 * 執行篩選並生成圖片預覽
 */
function applyFilter(){
    const fieldSelect=document.getElementById('filterField');
    const valueSelect=document.getElementById('filterValueSelect');
    const filterKey=fieldMap[fieldSelect.value]; // 取得實際的資料欄位名稱 (例如 "班期")
    const filterValue=valueSelect.value.trim().toLowerCase(); // 取得篩選值並轉小寫

    // 重設狀態
    resultsContainer.innerHTML='';
    downloadableItems=[];
    downloadAllBtn.disabled=true;
    hideMessage();

    if(!globalSheetData){ displayMessage('資料尚未載入',true); return; }
    if(!filterValue){ displayMessage('請選擇篩選值',true); return; }

    // 根據使用者選擇的欄位和值進行資料篩選
    const filtered = globalSheetData.filter(row=>{
        const v=row[filterKey];
        // 確保值存在、轉字串、去除空白並轉小寫後與篩選值比對
        return v && v.toString().trim().toLowerCase() === filterValue; 
    });

    // 處理無資料的情況
    if(filtered.length===0){
        displayMessage('找不到符合資料');
        resultsContainer.innerHTML=`<p>無資料：${valueSelect.value}</p>`;
        return;
    }

    displayMessage(`找到 ${filtered.length} 筆資料`);
    downloadAllBtn.disabled=false; // 找到資料後啟用下載全部按鈕

    // 遍歷所有篩選後的資料，並為每一筆生成一個預覽區塊
    filtered.forEach((row, index)=>{
        const itemDiv = document.createElement("div");
        itemDiv.className = "result-item";
        itemDiv.id = `item-${index}`; // 給予唯一 ID 方便截圖

        /* 圖片（背景圖） */
        const img = document.createElement("img");
        img.className = "result-img";
        // 設置 crossorigin 屬性，允許跨域圖片被 html-to-image 處理
        img.setAttribute('crossOrigin', 'anonymous'); 
        
        // 設置背景圖片 URL
        img.src = "https://chy0205.github.io/1110/1201.png";
        // 圖片載入失敗時的備用圖
        img.onerror = () => { 
            console.error('Image failed to load'); 
            img.src = 'https://placehold.co/720x1280/eeeeee/333333?text=背景圖載入失敗'; 
        };
        itemDiv.appendChild(img);

        /* 文字內容區塊 */
        const contentBlock = document.createElement("div");
        contentBlock.className = "content-block";

        // ★ 標題兩行文字處理 (日期 / 仙佛與班期)，計算長度以進行垂直對齊 ★
        
        let dateLineText = '';
        if(row["日期"]) {
            // 日期行：開頭一個半形空格
            dateLineText = `${row["日期"]}`; 
        }
        
        let deityCourseLineText = '';
        if(row["仙佛"] || row["班期"]){
            let text = ""; // 仙佛行：開頭一個全形空格，用於與日期行區隔
            if(row["仙佛"]) text += row["仙佛"];
            if(row["班期"]) text += `慈悲於${row["班期"]}`;
            deityCourseLineText = text;
        }

        // 找出兩行文字中最長的視覺長度（以字數計）作為對齊的目標長度
        const finalMaxLen = Math.max(dateLineText.length, deityCourseLineText.length);
        // 如果最長長度小於最小目標長度 (15)，則使用最小目標長度確保基礎寬度
        const targetLen = finalMaxLen > 1 ? finalMaxLen : ALIGN_MIN_TARGET_LEN;

        // 初始化最終內容字串 
        let finalContentString = "\n"; 
        
        // 1. 日期行：應用對齊函式，並加上換行符 (\n)
        finalContentString += generateAlignedSpan(dateLineText, targetLen) + '\n';

        // 2. 仙佛與班期行：應用對齊函式，並加上換行符 (\n)
        finalContentString += generateAlignedSpan(deityCourseLineText, targetLen) + '\n';


        const name = row["姓名"] || "";
        const content = row["內容"] || ""; // 獲取原始內容
        
        // ★ 內容文字縮排邏輯：確保內容與前面的標題有固定間隔 ★
        const FIXED_TOTAL_INDENT = 7; // 固定總縮排字元數 (從最右側列開始計算的縮排，包括姓名和分隔符號)
        
        // 1. 計算 namePrefix (姓名) 前需要的縮排 (indentString)
        const nameAndSeparatorLength = name.length + 1; // 姓名長度 + 1 (分隔符號 '|')
        // 需要在姓名之前填充的空格數
        const requiredPrefixSpaces = Math.max(0, FIXED_TOTAL_INDENT - nameAndSeparatorLength);
        
        const indentString = "　".repeat(requiredPrefixSpaces); // 產生前綴的全形縮排
        
        // 姓名行（例如：　蔡廣生|） - 位於內容區塊第一列的前綴
        const namePrefix = name ? `${indentString}${name}|` : "";

        // 設定每行最大字數，避免超出直式高度 (1280px)
        const maxCharsPerLine = 19; 
        // 呼叫斷行函式，處理原始內容中的換行和長度限制
        const wrappedContent = forceVerticalLineBreak(content, maxCharsPerLine);
        const lines = wrappedContent.split("\n"); // 獲取所有處理後的行

        // 2. 計算後續內容行的縮排字元串 (固定 8 格)
        const totalIndent = FIXED_TOTAL_INDENT;
        const contentIndentString = "　".repeat(totalIndent);

        let formatted = "";
        lines.forEach((line, i)=>{
            if(i===0) {
                // 內容的第一行直接接在 namePrefix 後面 (在同一列)
                formatted += line; 
            }
            else {
                // 第二行及以後的內容需要換行 (\n) (換到下一列) 
                // 並加入標準的內容縮排 (8 格) (從頂部垂直方向的縮排)
                formatted += '\n' + contentIndentString + line;
            }
        });

        // 將標頭、姓名和主要內容組合成完整的 HTML 字串
        let finalHTML = finalContentString + namePrefix + formatted;

        /* 區域文字處理 (位於內容結尾) */
        if(row["區域"]){
            // 取得實際內容的最後一行，用於判斷是否還有空間容納區域文字
            const lastContentLine = lines[lines.length - 1] || '';
            const lastLineLength = lastContentLine.length; 
            
            const maxCharsForSameLine = 15; // 臨界值：最後一行字數超過 15 則換列 (預留空間)

            let prefix = ''; 
            
            // 1. 如果最後一行字數 > 15 (空間不足，需要換到下一列/新行)
            if (lastLineLength > maxCharsForSameLine) {
                // 換行 (\n)，並加入標準的內容縮排 (8 格)
                prefix = '\n' + contentIndentString; 
            } 
            // 2. 如果最後一行字數 <= 15 (空間足夠，接在同一列/行後面)
            else {
                // 在同一列/行接續，只需要一個全形空格來分隔內容和區域
                prefix = ''; 
            }

            // 將區域內容用 span 包裹並應用 .small-text 類別 (較小的字體)
            const areaHtml = `<span class="small-text">（${row["區域"]}）</span>`;

            // 將區域文字附加到內容的尾部
            finalHTML += `${prefix}${areaHtml}`; 
        }

        // 將組裝好的 HTML 內容設置到內容區塊
        contentBlock.innerHTML = finalHTML;
        itemDiv.appendChild(contentBlock);

        /* 單一下載按鈕 */
        const btnWrapper = document.createElement("div");
        btnWrapper.className="download-button-wrapper";
        const btn=document.createElement("button");
        btn.className="btn-style";
        btn.textContent="下載 PNG";

        const filename=`${row["姓名"]||"未知"}-${row["區域"]||"未知"}`;
        // 設定單個按鈕的點擊事件，呼叫 generateImage 函式
        btn.onclick=()=>generateImage(itemDiv, filename);

        btnWrapper.appendChild(btn);
        itemDiv.appendChild(btnWrapper);

        resultsContainer.appendChild(itemDiv);
        // 儲存待下載項目資訊，供下載全部功能使用
        downloadableItems.push({element:itemDiv, filename});
    });
}

/**
 * 截圖並下載單個圖片 (用於單一按鈕)
 * @param {HTMLElement} element 要截圖的 DOM 元素
 * @param {string} filename 儲存檔名
 * @param {function():void} callback 下載完成後的回調函數
 */
async function generateImage(element, filename, callback=()=>{}){
    // 截圖前暫時隱藏下載按鈕，避免按鈕出現在圖片中
    const hideBtn = element.querySelector('.download-button-wrapper');
    if(hideBtn) hideBtn.style.display='none';

    try {
        // 使用 htmlToImage.toPng 將 DOM 元素轉換為 PNG 圖片的 Base64 URL
        const dataUrl = await htmlToImage.toPng(element);
        // 建立一個隱藏的 <a> 標籤來觸發下載
        const a=document.createElement('a');
        a.href=dataUrl;
        a.download=filename + ".png";
        document.body.appendChild(a);
        a.click(); // 觸發下載
        document.body.removeChild(a);
        callback();
    } catch(e){
        console.error("生成圖片失敗:", e);
        displayMessage(`生成圖片失敗: ${e.message}`, true); 
        callback();
    } finally {
        // 截圖後恢復顯示下載按鈕
        if(hideBtn) hideBtn.style.display='block';
    }
}

/**
 * 下載所有生成的圖片，並將其打包成 ZIP 檔案
 */
async function downloadAllImages(){
    if(downloadableItems.length===0) return;

    downloadAllBtn.disabled=true;
    displayMessage("開始打包 ZIP 檔案，請稍候...");

    // 1. 初始化 JSZip
    const zip = new JSZip();
    const folder = zip.folder("generated_images"); // 在 ZIP 內建立一個資料夾
    // 簡單的延遲函式，避免瀏覽器在短時間內處理大量 DOM-to-Image 任務而卡住
    const delay = ms => new Promise(r=>setTimeout(r, ms));

    try {
        // 2. 依序生成圖片 Blob 並加入 ZIP 檔案
        for(let i=0;i<downloadableItems.length;i++){
            const item = downloadableItems[i];
            // 截圖前暫時隱藏下載按鈕
            const hideBtn = item.element.querySelector('.download-button-wrapper');
            if(hideBtn) hideBtn.style.display='none';

            displayMessage(`處理中：${item.filename}.png (${i+1}/${downloadableItems.length})`);
            
            // 使用 htmlToImage.toBlob 取得圖片的 Blob 資料
            const imageBlob = await htmlToImage.toBlob(item.element, {
                quality: 0.95 // 設置圖片品質，95%
            });

            // 將 Blob 資料加入 ZIP 檔案，使用檔案名稱作為鍵
            folder.file(`${item.filename}.png`, imageBlob);

            // 截圖後恢復顯示下載按鈕
            if(hideBtn) hideBtn.style.display='block';
            
            // 暫停 500ms，給予瀏覽器緩衝和渲染時間
            await delay(500); 
        }

        // 3. 生成 ZIP 檔案 (Blob)
        displayMessage("正在壓縮檔案...");
        // 壓縮選項：type: "blob" 生成二進位大對象
        const zipBlob = await zip.generateAsync({type: "blob"});

        // 4. 使用 FileSaver.js 觸發下載
        saveAs(zipBlob, "試算表圖檔輸出.zip");

        displayMessage("ZIP 檔案下載完成！");
    } catch(e) {
        console.error("生成 ZIP 失敗:", e);
        displayMessage(`生成 ZIP 失敗: ${e.message}`, true);
    } finally {
        // 無論成功或失敗，最後都要啟用按鈕
        downloadAllBtn.disabled=false;
    }
}
</script>
</body>
</html>


