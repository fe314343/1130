<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>試算表篩選與直式圖檔生成</title>
<!-- 載入 html-to-image 函式庫用於圖片生成 -->
<script src="https://cdn.jsdelivr.net/npm/html-to-image@1.11.12/dist/html-to-image.min.js"></script>
<!-- 新增：JSZip 用於壓縮檔案 -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<!-- 新增：FileSaver.js 用於觸發檔案下載 -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>

<!-- ★ 修正：載入 Noto Serif TC（筆劃外觀最接近傳統楷體/標楷體的網路字體） ★ -->
<link href="https://fonts.googleapis.com/css2?family=Noto+Serif+TC:wght@400;700&display=swap" rel="stylesheet" crossorigin="anonymous">

<style>
/* 確保所有文字優先使用「標楷體」(BiauKai, KaiTi, DFKai-SB) */
body {
    /* 修正：將系統字體「標楷體」及其常見別名置於首位，確保在使用者裝置上有安裝時優先使用。 */
    font-family: "標楷體", "DFKai-SB", "KaiTi", 'Noto Serif TC', serif;
    background-color: #f0f0f0;
    margin: 0; padding: 20px;
    display: flex;
    flex-direction: column;
    align-items: center;
    min-height: 100vh;
}
.main-container {
    width: 90%; max-width: 1200px;
    padding: 20px;
    background: #fff;
    border-radius: 12px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.15);
}
#controls {
    display: flex; gap: 15px;
    margin-bottom: 15px;
    flex-wrap: wrap;
}
.control-group { display: flex; flex-direction: column; }
/* 明確指定下拉選單和按鈕使用標楷體 */
select, button {
    padding: 8px 10px;
    font-size: 1rem;
    border-radius: 5px;
    border: 1px solid #ccc;
    cursor: pointer;
    transition: background-color 0.3s;
    font-family: inherit; /* 繼承 body 的字體 */
}
.action-buttons {
    display: flex;
    gap: 15px;
    align-items: flex-end;
}
#resultsContainer {
    display: flex; gap: 20px;
    overflow-x: auto;
    padding: 10px 0;
    min-height: 500px;
}

/* =============================== */
/* ★ 直式圖檔生成區塊樣式 ★        */
/* =============================== */
.result-item {
    /* 確保寬高一致，符合直式圖檔比例 */
    width: 720px;
    height: 1280px;
    min-width: 720px;
    min-height: 1280px;
    position: relative;
    box-sizing: border-box;
    /* 移除邊框和圓角，讓輸出圖片乾淨利落，只包含內容 */
    border: none; 
    border-radius: 0;
    overflow: hidden; /* 防止內容預覽時溢出 */
}

/* 圖片完整顯示、不裁切、不變形 */
.result-img {
    width: 100%;
    height: 100%;
    object-fit: contain;
    position: absolute;
    top: 0; left: 0;
    z-index: 1;
}

/* 文字區塊（一定在圖片內） */
.content-block {
    position: absolute;
    z-index: 2;

    /* 調整定位以適應 vertical-rl (從右向左書寫) */
    top: 10px; 
    right: 5px; 

    /* height 控制每一行文字的長度 */
    height: calc(100% - 20px); 
    /* width 控制總共能寫多少行 */
    width: calc(100% - 10px); 
    overflow: hidden; /* 確保超出範圍的文字被隱藏 */

    /* 直式書寫設定 */
    writing-mode: vertical-rl;
    text-orientation: upright;
    
    /* ★ 確保所有圖檔內文字都是標楷體 */
    font-family: "標楷體", "DFKai-SB", "KaiTi", 'Noto Serif TC', serif;
    font-size: 32px;
    line-height: 1.2;
    letter-spacing: 10px; /* 增加字母間距/字距 - 此為基礎間距 */
    white-space: pre-wrap; /* 支援 \n 換行 */
    word-break: break-word;

    color: #333;
    /* 增加陰影讓文字在圖片上更清晰 */
    text-shadow: 0 0 3px rgba(255,255,255,0.9), 0 0 1px rgba(0,0,0,0.2); 
}

/* ★ 區域文字的樣式，字體大小設為 20px */
.small-text {
    font-size: 20px;
    /* ★ 確保所有圖檔內文字都是標楷體 */
    font-family: "標楷體", "DFKai-SB", "KaiTi", 'Noto Serif TC', serif;
}

/* 專門用於對齊的 span，沒有基礎間距 */
.content-block span {
    /* 確保 span 繼承所有基本設定，但我們只在 JS 中設定 letter-spacing */
    display: inline-block;
}

.download-button-wrapper {
    position: absolute;
    bottom: 10px;
    left: 10px;
    z-index: 5;
    writing-mode: horizontal-tb;
}

.btn-style {
    background-color: #4CAF50;
    color: white;
    padding: 8px 12px;
    border: none;
    border-radius: 5px;
    cursor: pointer;
}
.btn-style:hover {
    background-color: #45a049;
}
#downloadAllBtn {
    background-color: #007bff;
    color: white;
    padding: 10px 15px;
}
#downloadAllBtn:hover {
    background-color: #0056b3;
}
#downloadAllBtn:disabled {
    background-color: #cccccc;
    cursor: not-allowed;
}

@media (max-width: 768px) {
    .result-item {  /* 手機版適應 */
        width: 300px;
        height: 400px;
    }
}
</style>
</head>
<body>

<div class="main-container">
    <h1 style="text-align:center; margin-bottom:10px;">聖訓小卡生成</h1>

    <div id="controls">
        <div class="control-group">
            <label>選擇欄位:</label>
            <select id="filterField">
                <option value="班期">班期</option>
                <option value="日期">日期</option>
                <option value="仙佛">仙佛</option>
                <option value="姓名">姓名</option>
                <option value="內容">內容</option>
                <option value="區域">區域</option>
            </select>
        </div>

        <div class="control-group">
            <label>選擇值:</label>
            <select id="filterValueSelect" disabled>
                <option value="">請先選欄位</option>
            </select>
        </div>

        <div class="action-buttons">
            <button class="btn-style" onclick="applyFilter()">開始篩選</button>
            <!-- 變更按鈕文字為「下載為 ZIP」 -->
            <button id="downloadAllBtn" class="btn-style" onclick="downloadAllImages()" disabled>下載為 ZIP</button>
        </div>
    </div>

    <div id="messageBox" style="margin-bottom: 10px;"></div>
    <div id="resultsContainer"><p>請選擇篩選條件後點擊開始篩選。</p></div>
</div>

<script>
// Google Apps Script URL，用於獲取試算表資料
// 注意：此 URL 應指向您的 Google Apps Script 部署，以取得實際資料
const GS_SCRIPT_URL = 'https://script.google.com/macros/s/AKfycbzPsok1XF4E4PQEmckvxK3pY8GPI1GeTrceC5Oz5deQbDMvmgtJxd1e-WcIV4GjgxZV3g/exec';

const fieldMap = {
    "班期":"班期","日期":"日期","仙佛":"仙佛",
    "姓名":"姓名","內容":"內容","區域":"區域"
};

let globalSheetData = null;
let downloadableItems = [];
const messageBox = document.getElementById('messageBox');
const resultsContainer = document.getElementById('resultsContainer');
const downloadAllBtn = document.getElementById('downloadAllBtn');

// ★ 字元對齊相關常數
const CHAR_FONT_SIZE_PX = 34; // 字體大小
const BASE_LETTER_SPACING_PX = 10; // CSS 中 .content-block 的基礎間距
const VISUAL_CHAR_UNIT_PX = CHAR_FONT_SIZE_PX + BASE_LETTER_SPACING_PX; // 42px，一個字元佔用的視覺空間
const ALIGN_MIN_TARGET_LEN = 15; // 預設目標長度（字元數）


/**
 * 顯示訊息給使用者
 * @param {string} msg 訊息內容
 * @param {boolean} isError 是否為錯誤訊息
 */
function displayMessage(msg, isError=false){
    messageBox.textContent = msg;
    messageBox.style.color = isError ? 'red':'green';
}
function hideMessage(){ messageBox.textContent=''; }

/**
 * 針對直式書寫強制斷行，防止內容超出單行垂直空間。
 * @param {string} text 原始文字
 * @param {number} maxCharsPerLine 每行最大字數
 * @returns {string} 處理後的帶有換行符的文字
 */
function forceVerticalLineBreak(text, maxCharsPerLine=21) { 
    if (!text) return '';
    const originalLines = text.split('\n');
    let processedLines = [];
    
    for (const line of originalLines) {
        if (line.length > maxCharsPerLine) {
            let tempLine = '';
            let lineChunks = [];
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                if (tempLine.length === maxCharsPerLine) {
                    lineChunks.push(tempLine);
                    tempLine = char;
                } else {
                    tempLine += char;
                }
            }
            if (tempLine.length > 0) lineChunks.push(tempLine);
            // 將過長的行以換行符串接
            processedLines.push(lineChunks.join('\n'));
        } else {
            processedLines.push(line);
        }
    }
    // 將所有行以換行符串接
    return processedLines.join('\n');
}

/**
 * 根據最長行調整字元間距，以達到視覺上的垂直對齊 (長度一致)。
 * @param {string} text 要調整的文字內容。
 * @param {number} targetLen 目標長度 (字元數)。
 * @returns {string} 包含 inline style 的 <span> HTML 字串或原始文字。
 */
function generateAlignedSpan(text, targetLen) {
    if (!text || text.trim().length === 0) return text;
    // 使用文字的實際字數
    const currentLen = text.length;

    // 如果文字長度已經大於或等於目標長度，則無需調整間距
    if (currentLen >= targetLen) {
        return text;
    }

    // 我們需要補足的字元單位數量
    const neededCharUnits = targetLen - currentLen;
    // 總共需要的額外像素空間
    const totalExtraSpaceNeededPx = neededCharUnits * VISUAL_CHAR_UNIT_PX;
    
    const numGaps = currentLen - 1;

    let finalSpan = text;

    if (numGaps > 0) {
        // 將總額外空間平均分配到每個間隙中
        const extraSpacingPerGap = totalExtraSpaceNeededPx / numGaps;
        // 新的 letter-spacing = 基礎間距 + 每個間隙的額外間距
        const totalSpacing = BASE_LETTER_SPACING_PX + extraSpacingPerGap;
        
        // 將文字包裝在 span 內，並應用計算出的 letter-spacing
        finalSpan = `<span style="letter-spacing:${totalSpacing.toFixed(2)}px;">${text}</span>`;
    } else if (currentLen === 1) {
        // 如果只有一個字，無法調整間距，改為補全形空白
        finalSpan = text + '　'.repeat(neededCharUnits); 
    }
    
    return finalSpan;
}


/**
 * 獲取試算表資料
 */
async function fetchSheetData(){
    const selectElement = document.getElementById('filterValueSelect');
    selectElement.innerHTML = '<option>載入中...</option>';
    selectElement.disabled = true;
    resultsContainer.innerHTML = '<p>資料載入中，請稍候...</p>';
    hideMessage();
    try {
        const res = await fetch(GS_SCRIPT_URL);
        const data = await res.json();
        globalSheetData = data;
        displayMessage('資料載入成功');
        return data;
    } catch (e) {
        console.error('Fetch error:', e);
        displayMessage('資料載入失敗',true);
        return null;
    }
}

/**
 * 根據選定的欄位填充篩選值下拉選單
 * @param {Array<Object>} data 試算表資料
 * @param {string} fieldKey 欄位名稱
 */
function populateFilterValues(data, fieldKey){
    const selectElement = document.getElementById('filterValueSelect');
    selectElement.innerHTML = '';
    
    if (!data || data.length === 0){
        selectElement.disabled=true;
        return;
    }

    const uniqueValues = new Set();
    data.forEach(row=>{
        const val = row[fieldKey];
        if(val) uniqueValues.add(val.toString().trim());
    });
    
    // 按中文排序
    const sorted = Array.from(uniqueValues).sort((a,b)=>a.localeCompare(b,'zh-TW'));

    const def = document.createElement('option');
    def.value=''; def.textContent='--- 請選擇 ---';
    selectElement.appendChild(def);

    sorted.forEach(v=>{
        const o=document.createElement('option');
        o.value=v; o.textContent=v;
        selectElement.appendChild(o);
    });

    selectElement.disabled=false;
}

// 頁面載入後初始化
document.addEventListener('DOMContentLoaded', async()=>{
    // 使用非同步函式處理資料初始化
    const initializeData = async () => {
        if(!globalSheetData) await fetchSheetData();
        // 預設填充「班期」的篩選值
        if (globalSheetData) {
            populateFilterValues(globalSheetData, fieldMap["班期"]);
        }
    };

    await initializeData();
    
    // 監聽篩選欄位變更，並重新填充篩選值
    document.getElementById('filterField').addEventListener('change', (event)=>{ 
        populateFilterValues(globalSheetData, fieldMap[event.target.value]);
    });
});

/**
 * 執行篩選並生成圖片預覽
 */
function applyFilter(){
    const fieldSelect=document.getElementById('filterField');
    const valueSelect=document.getElementById('filterValueSelect');
    const filterKey=fieldMap[fieldSelect.value];
    const filterValue=valueSelect.value.trim().toLowerCase();

    resultsContainer.innerHTML='';
    downloadableItems=[];
    downloadAllBtn.disabled=true;
    hideMessage();

    if(!globalSheetData){ displayMessage('資料尚未載入',true); return; }
    if(!filterValue){ displayMessage('請選擇篩選值',true); return; }

    const filtered = globalSheetData.filter(row=>{
        const v=row[filterKey];
        return v && v.toString().trim().toLowerCase() === filterValue;
    });

    if(filtered.length===0){
        displayMessage('找不到符合資料');
        resultsContainer.innerHTML=`<p>無資料：${valueSelect.value}</p>`;
        return;
    }

    displayMessage(`找到 ${filtered.length} 筆資料`);
    downloadAllBtn.disabled=false;

    filtered.forEach((row, index)=>{
        const itemDiv = document.createElement("div");
        itemDiv.className = "result-item";
        itemDiv.id = `item-${index}`; // 給予ID方便截圖

        /* 圖片（背景圖，保持不裁切、不變形） */
        const img = document.createElement("img");
        img.className = "result-img";
        // 增加 crossorigin="anonymous" 解決 html-to-image 讀取跨域圖片的 SecurityError
        img.setAttribute('crossOrigin', 'anonymous'); 
        
        // 替換為您的圖片 URL
        img.src = "https://chy0205.github.io/1110/1201.png";
        img.onerror = () => { console.error('Image failed to load'); img.src = 'https://placehold.co/720x1280/eeeeee/333333?text=背景圖載入失敗'; };
        itemDiv.appendChild(img);

        /* 文字內容區塊 */
        const contentBlock = document.createElement("div");
        contentBlock.className = "content-block";

        // ★ 處理標頭兩行文字，計算長度以進行對齊
        let dateLineText = '';
        if(row["日期"]) {
            dateLineText = ` ${row["日期"]}`; // 開頭一個半形空格
        }
        
        let deityCourseLineText = '';
        if(row["仙佛"] || row["班期"]){
            let text = "　"; // 開頭一個全形空格
            if(row["仙佛"]) text += row["仙佛"];
            if(row["班期"]) text += `慈悲於${row["班期"]}`;
            deityCourseLineText = text;
        }

        // 找出最長的視覺長度（以字數計）作為目標
        const finalMaxLen = Math.max(dateLineText.length, deityCourseLineText.length);
        const targetLen = finalMaxLen > 1 ? finalMaxLen : ALIGN_MIN_TARGET_LEN;

        let finalContentString = "\n"; 
        
        // 1. 日期行：應用對齊
        finalContentString += generateAlignedSpan(dateLineText, targetLen) + '\n';

        // 2. 仙佛與班期行：應用對齊
        finalContentString += generateAlignedSpan(deityCourseLineText, targetLen) + '\n';


        const name = row["姓名"] || "";
        const content = row["內容"] || ""; // 獲取原始內容
        
        // ★ 根據使用者要求，固定內容的起始位置總共偏移 8 個字元 (包括姓名和分隔符號)
        const FIXED_TOTAL_INDENT = 8;
        
        // 1. 計算 namePrefix 前需要的縮排 (indentString)
        const nameAndSeparatorLength = name.length + 1; // 姓名長度 + 1 (分隔符號 '|')
        const requiredPrefixSpaces = Math.max(0, FIXED_TOTAL_INDENT - nameAndSeparatorLength);
        
        const indentString = "　".repeat(requiredPrefixSpaces); // 計算新的前綴縮排 (取代原來的 indent4)
        
        // 姓名（蔡廣生|） - 位於第一行的前綴
        // 確保總長度為 FIXED_TOTAL_INDENT
        const namePrefix = name ? `${indentString}${name}|` : "";

        // 設定每行最大字數，避免超出直式高度
        const maxCharsPerLine = 19; 
        const wrappedContent = forceVerticalLineBreak(content, maxCharsPerLine);
        const lines = wrappedContent.split("\n");

        // 2. 計算後續行的縮排字元數：固定為 8 
        const totalIndent = FIXED_TOTAL_INDENT;
        const contentIndentString = "　".repeat(totalIndent);

        let formatted = "";
        lines.forEach((line, i)=>{
            if(i===0) {
                // 第一行文字內容不需要額外的 contentIndentString，因為 namePrefix 已經提供了開頭縮排
                formatted += line; 
            }
            else {
                // 第二行及以後的內容需要換行並縮排對齊第一行姓名之後的位置 (固定 8 格)
                formatted += '\n' + contentIndentString + line;
            }
        });

        // 由於區域文字需要應用不同的樣式，我們將內容變數改為支援 HTML
        let finalHTML = finalContentString + namePrefix + formatted;

        /* 區域 - 實作換行邏輯 (根據最後一行內容字數決定是否換列) */
        if(row["區域"]){
            // 取得實際內容的最後一行 (lines 陣列中最後一個元素)
            const lastContentLine = lines[lines.length - 1] || '';
            const lastLineLength = lastContentLine.length; 
            
            // 使用者要求：臨界值為 15
            const maxCharsForSameLine = 15; 

            let prefix = ''; 
            
            // 1. 如果最後一行字數 > 15 (需要換到下一列/新行，並有縮排)
            if (lastLineLength > maxCharsForSameLine) {
                // 換到新的一列 (\n)，並加入標準的內容縮排 (contentIndentString，此時為固定的 8 格)
                prefix = '\n' + contentIndentString; 
            } 
            // 2. 如果最後一行字數 <= 15 (接在內容的下面/同一列，加全形空格分隔)
            else {
                // 在同一列/行接續，只需要一個全形空格來分隔內容和區域
                prefix = ''; 
            }

            // 將區域內容用 <span> 包裹並應用 .small-text 類別
            const areaHtml = `<span class="small-text">（${row["區域"]}）</span>`;

            // 在區域文字前後加上全形括號，並與內容文字串接
            finalHTML += `${prefix}${areaHtml}`; 
        }

        // ★ 修正：改用 innerHTML 支援 HTML 標籤
        contentBlock.innerHTML = finalHTML;
        itemDiv.appendChild(contentBlock);

        /* 下載按鈕 */
        const btnWrapper = document.createElement("div");
        btnWrapper.className="download-button-wrapper";
        const btn=document.createElement("button");
        btn.className="btn-style";
        btn.textContent="下載 PNG"; // 單獨下載按鈕仍是下載 PNG

        const filename=`${row["姓名"]||"未知"}-${row["區域"]||"未知"}`;
        btn.onclick=()=>generateImage(itemDiv, filename);

        btnWrapper.appendChild(btn);
        itemDiv.appendChild(btnWrapper);

        resultsContainer.appendChild(itemDiv);
        downloadableItems.push({element:itemDiv, filename});
    });
}

/**
 * 截圖並下載單個圖片 (用於單一按鈕)
 * @param {HTMLElement} element 要截圖的 DOM 元素
 * @param {string} filename 儲存檔名
 * @param {function():void} callback 下載完成後的回調函數
 */
async function generateImage(element, filename, callback=()=>{}){
    // 截圖前暫時隱藏下載按鈕
    const hideBtn = element.querySelector('.download-button-wrapper');
    if(hideBtn) hideBtn.style.display='none';

    try {
        // 使用 htmlToImage 轉換為 PNG 圖片資料 URL
        const dataUrl = await htmlToImage.toPng(element);
        const a=document.createElement('a');
        a.href=dataUrl;
        a.download=filename + ".png";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        callback();
    } catch(e){
        console.error("生成圖片失敗:", e);
        // 顯示錯誤訊息
        displayMessage(`生成圖片失敗: ${e.message}`, true); 
        callback();
    } finally {
        // 截圖後恢復顯示下載按鈕
        if(hideBtn) hideBtn.style.display='block';
    }
}

/**
 * 下載所有生成的圖片，並將其打包成 ZIP 檔案
 */
async function downloadAllImages(){
    if(downloadableItems.length===0) return;

    downloadAllBtn.disabled=true;
    displayMessage("開始打包 ZIP 檔案，請稍候...");

    // 1. 初始化 JSZip
    const zip = new JSZip();
    const folder = zip.folder("generated_images");
    const delay = ms => new Promise(r=>setTimeout(r, ms));

    try {
        // 2. 依序生成圖片 Blob 並加入 ZIP 檔案
        for(let i=0;i<downloadableItems.length;i++){
            const item = downloadableItems[i];
            // 截圖前暫時隱藏下載按鈕
            const hideBtn = item.element.querySelector('.download-button-wrapper');
            if(hideBtn) hideBtn.style.display='none';

            displayMessage(`處理中：${item.filename}.png (${i+1}/${downloadableItems.length})`);
            
            // 使用 htmlToImage.toBlob 取得圖片 Blob
            const imageBlob = await htmlToImage.toBlob(item.element, {
                // 確保背景圖完全載入 (雖然此處已設定onerror，但為保險仍保留)
                // 且為了壓縮後檔案大小，設定為 PNG 格式
                quality: 0.95 
            });

            // 將 Blob 加入 ZIP 檔案
            folder.file(`${item.filename}.png`, imageBlob);

            // 截圖後恢復顯示下載按鈕
            if(hideBtn) hideBtn.style.display='block';
            
            // 加入延遲，防止瀏覽器過度佔用資源
            await delay(500); 
        }

        // 3. 生成 ZIP 檔案 (Blob)
        displayMessage("正在壓縮檔案...");
        const zipBlob = await zip.generateAsync({type: "blob"});

        // 4. 使用 FileSaver.js 觸發下載
        saveAs(zipBlob, "試算表圖檔輸出.zip");

        displayMessage("ZIP 檔案下載完成！");
    } catch(e) {
        console.error("生成 ZIP 失敗:", e);
        displayMessage(`生成 ZIP 失敗: ${e.message}`, true);
    } finally {
        downloadAllBtn.disabled=false;
    }
}
</script>
</body>
</html>
