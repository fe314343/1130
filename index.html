<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<!-- 設定 viewport 確保網頁在移動裝置上能正確縮放 -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>聖訓小卡生成 (iOS修復版)</title>

<!-- 載入 html-to-image 函式庫，用於將 HTML 元素轉換為圖片 (DOM 截圖) -->
<script src="https://cdn.jsdelivr.net/npm/html-to-image@1.11.12/dist/html-to-image.min.js"></script>
<!-- 載入 JSZip 函式庫，用於將多個圖片打包成一個 ZIP 壓縮檔 -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<!-- 載入 FileSaver.js 函式庫，用於在瀏覽器端觸發檔案下載流程 -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>

<!-- 引入 Google Fonts 的 Noto Serif TC (思源宋體 繁體中文)，作為標楷體的備用字體 -->
<link href="https://fonts.googleapis.com/css2?family=Noto+Serif+TC:wght%40400%3B700&display=swap" rel="stylesheet" crossorigin="anonymous">

<style>
/* ---------------------------------------------------- */
/* ★ 全域樣式設定 (Global Styles) ★                         */
/* ---------------------------------------------------- */
body {
    /* 字體設定：優先使用使用者系統內建的「標楷體」或其常見別名，以符合書寫風格。
       如果都找不到，則使用思源宋體 (Noto Serif TC)。 */
    font-family: "標楷體", "DFKai-SB", "KaiTi", 'Noto Serif TC', serif;
    background-color: #f0f0f0; /* 頁面背景色 */
    margin: 0; padding: 20px; /* 頁面邊距 */
    display: flex; /* 使用 Flexbox 進行佈局 */
    flex-direction: column; /* 垂直排列子元素 */
    align-items: center; /* 水平居中對齊 */
    min-height: 100vh; /* 確保內容區塊至少佔滿整個視窗高度 */
}
.main-container {
    width: 90%; max-width: 1200px; /* 設定最大寬度並居中 */
    padding: 20px;
    background: #fff; /* 白色背景 */
    border-radius: 12px; /* 圓角邊框 */
    box-shadow: 0 4px 15px rgba(0,0,0,0.15); /* 陰影效果 */
}
#controls {
    display: flex; gap: 15px; /* 控制項間距 */
    margin-bottom: 15px;
    flex-wrap: wrap; /* 允許控制項在小螢幕上換行 */
}
.control-group { display: flex; flex-direction: column; } /* 控制項分組，垂直排列 Label 和 Select */
/* 下拉選單和按鈕的基礎樣式 */
select, button, input[type="number"] {
    padding: 8px 10px;
    font-size: 1rem;
    border-radius: 5px;
    border: 1px solid #ccc;
    cursor: pointer;
    transition: background-color 0.3s;
    font-family: inherit; /* 繼承 body 的字體設定，確保中文字體一致 */
}
.action-buttons {
    display: flex;
    gap: 15px;
    align-items: flex-end; /* 底部對齊，讓按鈕與下拉選單的底部對齊 */
}
#resultsContainer {
    display: flex; gap: 20px;
    overflow-x: auto; /* 允許水平滾動查看所有生成的圖片預覽 */
    padding: 10px 0;
    min-height: 500px; /* 確保結果容器有足夠高度，避免內容跳動 */
}

/* ---------------------------------------------------- */
/* ★ 直式圖檔生成區塊樣式 (截圖目標: .result-item) ★        */
/* ---------------------------------------------------- */
.result-item {
    /* 固定的圖片尺寸：720x1280 像素，常見的直式手機螢幕比例，這是截圖的邊界 */
    width: 720px;
    height: 1280px;
    min-width: 720px;
    min-height: 1280px;
    position: relative; /* 設置相對定位，以容納絕對定位的文字和圖片 */
    box-sizing: border-box; /* 確保 padding/border 不會增加總尺寸 */
    border: none; 
    border-radius: 0;
    overflow: hidden; /* 確保內容在截圖邊界內 */
    background-color: #fff; /* 預設白色背景，防止圖片載入失敗時透明 */
}

/* 背景圖片樣式 */
.result-img {
    width: 100%;
    height: 100%;
    object-fit: contain; /* 確保圖片不變形地適應容器 */
    position: absolute;
    top: 0; left: 0;
    z-index: 1; /* 位於下層，作為背景 */
}

/* 文字內容區塊共用樣式 - 實作直式書寫 */
.content-block {
    position: absolute;
    z-index: 2; /* 位於上層，覆蓋背景圖片 */
    height: calc(100% - 50px); /* 垂直方向的長度（即字行的高度，1230px） */
    
    /* ★ 核心：設定直式書寫模式（從右向左，即列從右邊開始排） */
    writing-mode: vertical-rl;
    /* 確保所有字元（包括數字和英文字母）都保持直立，不旋轉 90 度 */
    text-orientation: upright;
    
    font-family: "標楷體", "DFKai-SB", "KaiTi", 'Noto Serif TC', serif;
    line-height: 1.3; /* 行距 (控制字行之間的垂直距離) */
    letter-spacing: 13px; /* 基礎字元間距 (控制字元間的水平距離) */
    /* 移除 white-space: pre-wrap; 以便在 JS 中手動控制換行和縮排 */
    white-space: pre; /* 只在 \n 處換行，不自動換行 */
    word-break: break-all; /* 允許長單詞或連續字符在任何位置斷開 */

    color: #333;
    /* 輕微的文字陰影，讓文字在複雜背景圖片上更清晰，增強可讀性 */
    text-shadow: 0 0 3px rgba(255,255,255,0.9), 0 0 1px rgba(0,0,0,0.2); 
}

/* 標題區塊：固定定位在最右側 */
.header-block {
    top: 30px; /* 統一與主內容區塊的頂部邊距 */
    right: 5px; 
    /* 標題區塊固定寬度，預留給兩行 32px 的字體 + 間距 */
    width: 140px; 
}

/* 主內容區塊：向左移，避開標題區塊，寬度佔據剩餘空間 */
.main-content-block {
    top: 30px; 
    right: 140px; /* 預留 100px 給標題區塊 + 20px 間隔 */
    width: calc(100% - 120px); /* 剩下的寬度 */
}

/* 區域文字的樣式：字體較小 (此處的 20px 仍然是固定值) */
.small-text {
    font-size: 20px;
    font-family: "標楷體", "DFKai-SB", "KaiTi", 'Noto Serif TC', serif;
    /* 這裡的 white-space: nowrap; 確保區域文字本身不會被垂直斷開，而是整體換列 */
    white-space: nowrap;
}

/* 專門用於對齊的 span 元素，需要設定 display: inline-block 才能應用 letter-spacing */
.content-block span {
    display: inline-block;
    /* 標題的 font-size 將會被 generateAlignedSpan 函數內的 inline style 覆蓋為動態值 */
}

/* 下載按鈕的樣式和定位 */
.download-button-wrapper {
    position: absolute;
    bottom: 10px;
    left: 10px;
    z-index: 5; /* 確保按鈕在最上層 */
    writing-mode: horizontal-tb; /* 確保按鈕文字是橫式，不被直式書寫影響 */
}

/* (其他按鈕樣式保持不變...) */
.btn-style {
    background-color: #4CAF50; /* 按鈕基本顏色 */
    color: white;
    padding: 8px 12px;
    border: none;
    border-radius: 5px;
    cursor: pointer;
}
.btn-style:hover {
    background-color: #45a049;
}
/* 下載全部按鈕的特殊樣式 */
#downloadAllBtn {
    background-color: #007bff;
    color: white;
    padding: 10px 15px;
}
#downloadAllBtn:hover {
    background-color: #0056b3;
}
#downloadAllBtn:disabled {
    background-color: #cccccc;
    cursor: not-allowed;
}

/* 媒體查詢：適應手機螢幕，將預覽圖縮小 */
@media (max-width: 768px) {
    .result-item {
        width: 300px;
        height: 400px;
    }
}
</style>
</head>
<body>

<div class="main-container">
    <h1 style="text-align:center; margin-bottom:10px;">聖訓小卡生成</h1>

    <div id="controls">
        <div class="control-group">
            <label>選擇欄位:</label>
            <select id="filterField">
                <option value="班期">班期</option>
                <option value="日期">日期</option>
                <option value="仙佛">仙佛</option>
                <option value="姓名">姓名</option>
                <option value="內容">內容</option>
                <option value="區域">區域</option>
            </select>
        </div>

        <div class="control-group">
            <label>選擇值:</label>
            <!-- 預設禁用，等資料載入後啟用 -->
            <select id="filterValueSelect" disabled>
                <option value="">請先選欄位</option>
            </select>
        </div>
        
        <!-- NEW: 字體大小輸入欄位 -->
        <div class="control-group">
            <label for="fontSizeInput">主內容字體大小 (px):</label>
            <input type="number" id="fontSizeInput" value="32" min="10" max="60" style="width: 100px;">
        </div>
        <!-- END NEW -->

        <div class="action-buttons">
            <button class="btn-style" onclick="applyFilter()">開始篩選</button>
            <!-- 下載所有圖片為 ZIP 檔案的按鈕 -->
            <button id="downloadAllBtn" class="btn-style" onclick="downloadAllImages()" disabled>下載為 ZIP</button>
        </div>
    </div>

    <!-- 用於顯示系統訊息或錯誤提示 -->
    <div id="messageBox" style="margin-bottom: 10px;"></div>
    <!-- 圖片結果預覽的容器 -->
    <div id="resultsContainer"><p>請選擇篩選條件後點擊開始篩選。</p></div>
</div>

<script>
// ----------------------------------------------------
// ★ JavaScript 核心邏輯 ★
// ----------------------------------------------------

// Google Apps Script 部署的 URL，用於從 Google Sheets 獲取 JSON 資料
const GS_SCRIPT_URL = 'https://script.google.com/macros/s/AKfycbzPsok1XF4E4PQEmckvxK3pY8GPI1GeTrceC5Oz5deQbDMvmgtJxd1e-WcIV4GjgxZV3g/exec';
// 背景圖片的原始網址 (請確保此圖片允許 CORS，或是相對路徑)
const BG_IMAGE_URL = './1201.png';

// ★ 模擬資料 (如果外部 Google Sheet 載入失敗時使用) ★
const MOCK_DATA = [
    {"班期": "第一班", "日期": "二零二四年一月一日", "仙佛": "濟公活佛", "姓名": "張三", "內容": "為了解決資料載入失敗的問題，我們加入了模擬資料。現在即使網路或伺服器出錯，應用程式也能正常啟動。內容會自動換行，不受高度限制。這一段文字很長，長度測試！長度測試！長度測試！長度測試！長度測試！長度測試！長度測試！長度測試！長度測試！長度測試！長度測試！長度測試！長度測試！長度測試！長度測試！長度測試！長度測試！長度測試！長度測試！長度測試！長度測試！長度測試！長度測試！長度測試！長度測試！長度測試！長度測試！長度測試！長度測試！長度測試！長度測試！長度測試！長度測試！長度測試！長度測試！長度測試！長度測試！長度測試！長度測試！長度測試！長度測試！長度測試！長度測試！長度測試！長度測試！長度測試！", "區域": "台北"},
    {"班期": "第二班", "日期": "二零二四年二月二日", "仙佛": "觀音大士", "姓名": "李四", "內容": "這是一個較短的內容範例。字數較少時，排版也會很整齊。這個內容很短，並且這是第二段內容。第二段內容也要縮排才行！", "區域": "台中"},
];

// 欄位名稱映射表，用於從下拉選單的值對應到 JSON 資料的鍵
const fieldMap = {
    "班期":"班期","日期":"日期","仙佛":"仙佛",
    "姓名":"姓名","內容":"內容","區域":"區域"
};

let globalSheetData = null; // 儲存從試算表載入的所有資料
let downloadableItems = []; // 儲存所有待下載的圖片元素和檔名資訊
// 儲存已轉換為 Base64 的背景圖，避免重複下載
let cachedBgBase64 = null; 

const messageBox = document.getElementById('messageBox');
const resultsContainer = document.getElementById('resultsContainer');
const downloadAllBtn = document.getElementById('downloadAllBtn');

// ★ 字元對齊和間距相關常數 - 這是直式標題對齊的核心 ★
const BASE_LETTER_SPACING_PX = 13; // CSS 中 .content-block 設定的基礎字距
const ALIGN_MIN_TARGET_LEN = 15; // 當兩行標題都太短時，預設對齊的最小目標長度

// ★ 標題區塊的垂直目標高度 (1280px 總高 - 50px 頂底邊距 = 1230px)
const HEADER_TARGET_HEIGHT_PX = 1210;
// 【修正】新增：為標題動態字體計算預留 5px 的安全邊距，防止字體溢出。
const HEADER_SAFETY_MARGIN_PX = 5; 
// 標題字體大小的限制範圍 (確保可讀性與美觀)
const HEADER_FONT_SIZE_MIN = 20;
const HEADER_FONT_SIZE_MAX = 36;

/**
 * 根據字數和固定間距，動態計算填滿目標高度所需的字體大小。
 * 公式: Size = [Total Height - (Spacing * (N - 1)) - Safety Margin] / N
 * @param {number} N_chars 兩行中最大的字元數
 * @returns {number} 經限制後的字體大小 (px)
 */
function calculateDynamicHeaderFontSize(N_chars) {
    if (N_chars <= 0) return HEADER_FONT_SIZE_MIN;
    
    // 如果只有一個字，則沒有間隔 (N-1=0)，只需填滿 1230px
    const numGaps = Math.max(0, N_chars - 1); 
    
    // 【修正應用】從總高度中減去安全邊距
    const availableHeight = HEADER_TARGET_HEIGHT_PX - HEADER_SAFETY_MARGIN_PX;
    const dynamicSize = (availableHeight - (BASE_LETTER_SPACING_PX * numGaps)) / N_chars;
    
    // 應用最小和最大限制
    return Math.max(HEADER_FONT_SIZE_MIN, Math.min(HEADER_FONT_SIZE_MAX, dynamicSize));
}

/**
 * 顯示訊息給使用者
 */
function displayMessage(msg, isError=false){
    messageBox.textContent = msg;
    messageBox.style.color = isError ? 'red':'green';
}
function hideMessage(){ messageBox.textContent=''; }

/**
 * 預先載入背景圖片並轉換為 Base64 DataURL。
 * 這是解決 iOS Safari 截圖背景空白最有效的方法。
 */
async function preloadBackground() {
    if (cachedBgBase64) return cachedBgBase64;
    
    try {
        console.log("開始下載背景圖並轉換...");
        // 嘗試獲取圖片
        const response = await fetch(BG_IMAGE_URL, { mode: 'cors' });
        
        // 如果是本地檔案或跨域失敗，fetch 可能會報錯或 not ok，這裡做基本檢查
        if (!response.ok) {
             console.warn("Fetch response not ok:", response.status);
             // 即使不 OK，有時本地測試也會進這裡，若無法轉 Base64，回傳原網址作為備案
             return BG_IMAGE_URL;
        }
        
        const blob = await response.blob();
        
        // 將 Blob 轉為 Base64 字串
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onloadend = () => {
                cachedBgBase64 = reader.result;
                console.log("背景圖轉換 Base64 成功");
                resolve(reader.result);
            };
            reader.onerror = (e) => {
                console.error("FileReader error", e);
                // 失敗時回傳原網址，盡人事
                resolve(BG_IMAGE_URL);
            };
            reader.readAsDataURL(blob);
        });
    } catch (e) {
        console.warn("無法轉換背景圖為 Base64 (可能是跨域限制或本地檔案)，將退回使用原始網址。", e);
        return BG_IMAGE_URL;
    }
}

/**
 * 根據最長行調整字元間距，以達到視覺上的垂直對齊 (長度一致)。
 * @param {string} text 要處理的文字
 * @param {number} targetLen 目標長度 (以字元計)
 * @param {number} sizeToUse 當前使用的字體大小 (px) - 用於計算間距和強制樣式
 * @returns {string} 加上動態 letter-spacing 和 font-size 的 HTML span 標籤或原文字串
 */
function generateAlignedSpan(text, targetLen, sizeToUse) {
    if (!text || text.trim().length === 0) return text;
    const currentLen = text.length;
    
    // 如果長度已經足夠，或文字長度不為 1，則只需要加上 font-size 樣式，確保固定字體大小
    if (currentLen >= targetLen) {
        return `<span style="font-size: ${sizeToUse}px;">${text}</span>`;
    }

    // 動態計算一個字元在直式書寫中佔用的視覺空間 (字體大小 + 基礎字距)
    const visualCharUnitPx = sizeToUse + BASE_LETTER_SPACING_PX; 

    const neededCharUnits = targetLen - currentLen;
    const totalExtraSpaceNeededPx = neededCharUnits * visualCharUnitPx;
    const numGaps = currentLen - 1;
    let finalSpan = text;

    if (numGaps > 0) {
        // 將總額外間距平均分配到字元間的空隙中
        const extraSpacingPerGap = totalExtraSpaceNeededPx / numGaps;
        // 最終的 letter-spacing = 基礎間距 + 額外間距
        const totalSpacing = BASE_LETTER_SPACING_PX + extraSpacingPerGap;
        // 強制設定 font-size 和 letter-spacing
        finalSpan = `<span style="font-size: ${sizeToUse}px; letter-spacing:${totalSpacing.toFixed(2)}px;">${text}</span>`;
    } else if (currentLen === 1) {
        // 如果只有一個字，則使用全形空格來推移，達成視覺長度一致
        finalSpan = `<span style="font-size: ${sizeToUse}px;">${text + '　'.repeat(neededCharUnits)}</span>`; 
    } else {
         // 作為備用情況，確保至少有 font-size 樣式
         finalSpan = `<span style="font-size: ${sizeToUse}px;">${text}</span>`;
    }
    
    return finalSpan;
}

/**
 * 異步獲取試算表資料，並更新 UI 狀態
 */
async function fetchSheetData(){
    const selectElement = document.getElementById('filterValueSelect');
    selectElement.innerHTML = '<option>載入中...</option>';
    selectElement.disabled = true;
    resultsContainer.innerHTML = '<p>資料載入中，請稍候...</p>';
    hideMessage();
    try {
        const res = await fetch(GS_SCRIPT_URL);
        const data = await res.json();
        globalSheetData = data;
        displayMessage('資料載入成功');
        return data;
    } catch (e) {
        console.error('Fetch error (外部資料載入失敗):', e);
        // ★ 核心修復：如果外部資料載入失敗，則使用模擬資料 (MOCK_DATA) ★
        globalSheetData = MOCK_DATA; 
        displayMessage('外部資料載入失敗，已使用模擬資料啟動。請檢查網路或 Google Apps Script URL。', true);
        resultsContainer.innerHTML = '<p>已使用模擬資料啟動。請選擇篩選條件後點擊開始篩選。</p>';
        return MOCK_DATA;
    }
}

/**
 * 根據選定的欄位填充篩選值下拉選單
 */
function populateFilterValues(data, fieldKey){
    const selectElement = document.getElementById('filterValueSelect');
    selectElement.innerHTML = '';
    
    if (!data || data.length === 0){
        selectElement.disabled=true;
        return;
    }

    const uniqueValues = new Set();
    data.forEach(row=>{
        const val = row[fieldKey];
        if(val) uniqueValues.add(val.toString().trim());
    });
    
    const sorted = Array.from(uniqueValues).sort((a,b)=>a.localeCompare(b,'zh-TW'));

    const def = document.createElement('option');
    def.value=''; def.textContent='--- 請選擇 ---';
    selectElement.appendChild(def);

    sorted.forEach(v=>{
        const o=document.createElement('option');
        o.value=v; o.textContent=v;
        selectElement.appendChild(o);
    });

    selectElement.disabled=false;
}

// 頁面載入後初始化
document.addEventListener('DOMContentLoaded', async()=>{
    // ★ iOS 關鍵修復：盡早開始轉換背景圖 ★
    // 我們不等待它完成，讓它在背景執行，applyFilter 時會 await 它
    preloadBackground(); 

    const initializeData = async () => {
        // 確保資料載入，無論是來自外部還是模擬
        if(!globalSheetData) await fetchSheetData();
        if (globalSheetData) {
            populateFilterValues(globalSheetData, fieldMap["班期"]);
        }
    };
    await initializeData();
    
    document.getElementById('filterField').addEventListener('change', (event)=>{ 
        populateFilterValues(globalSheetData, fieldMap[event.target.value]);
    });
});

/**
 * 執行篩選並生成圖片預覽
 * 注意：這裡改為 async 函式，因為要等待圖片轉換
 */
async function applyFilter(){
    const fieldSelect=document.getElementById('filterField');
    const valueSelect=document.getElementById('filterValueSelect');
    const filterKey=fieldMap[fieldSelect.value];
    const filterValue=valueSelect.value.trim().toLowerCase();
    
    // NEW: 獲取字體大小輸入 (用於主要內容)
    const fontSizeInput = document.getElementById('fontSizeInput');
    const currentFontSize = parseInt(fontSizeInput.value) || 32; // 使用 32 作為預設值或備用值

    resultsContainer.innerHTML='';
    downloadableItems=[];
    downloadAllBtn.disabled=true;
    hideMessage();

    if(!globalSheetData){ displayMessage('資料尚未載入',true); return; }
    if(!filterValue){ displayMessage('請選擇篩選值',true); return; }

    // ★ iOS 關鍵修復：確保背景圖已準備好 (如果是第一次點擊，這裡會等待轉換完成) ★
    const bgSrc = await preloadBackground();

    const filtered = globalSheetData.filter(row=>{
        const v=row[filterKey];
        return v && v.toString().trim().toLowerCase() === filterValue; 
    });

    if(filtered.length===0){
        displayMessage('找不到符合資料');
        resultsContainer.innerHTML=`<p>無資料：${valueSelect.value}</p>`;
        return;
    }

    displayMessage(`找到 ${filtered.length} 筆資料`);
    downloadAllBtn.disabled=false;

    // Helper function to break a long string into segments of max length
    /**
     * @param {string} text 要分割的長字串
     * @param {number} maxLength 每段的最大字元數
     * @returns {string[]} 分割後的字串陣列
     */
    function segmentLine(text, maxLength) {
        if (maxLength <= 0) return [text]; // 避免無限迴圈或錯誤
        const segments = [];
        while (text.length > 0) {
            segments.push(text.substring(0, maxLength));
            text = text.substring(maxLength);
        }
        return segments;
    }

    filtered.forEach((row, index)=>{
        const itemDiv = document.createElement("div");
        itemDiv.className = "result-item";
        itemDiv.id = `item-${index}`;

        /* 圖片（背景圖） */
        const img = document.createElement("img");
        img.className = "result-img";
        // ★ iOS 關鍵修復：使用 Base64 作為來源，避開 CORS 問題 ★
        img.src = bgSrc; 
        
        // 如果轉換失敗導致 src 仍是 URL，加上 crossOrigin 作為保險
        if (bgSrc === BG_IMAGE_URL) {
            img.crossOrigin = "anonymous";
        }

        img.onerror = () => { 
            console.error('Image failed to load in DOM'); 
            img.src = 'https://placehold.co/720x1280/eeeeee/333333?text=背景圖載入失敗'; 
        };
        itemDiv.appendChild(img);
        
        // --- 1. 標題區塊處理 (動態字體) ---
        /* 標題內容區塊 (動態字體) */
        const headerBlock = document.createElement("div");
        headerBlock.className = "content-block header-block"; 

        let dateLineText = '';
        if(row["日期"]) {
            dateLineText = `${row["日期"]}`; 
        }
        
        let deityCourseLineText = '';
        // 依照您的需求，仙佛 + "慈悲於" + 班期 
        const fixedMiddleText = "慈悲於"; // 假設這三個字是固定的
        if(row["仙佛"] || row["班期"]){
            let text = ""; 
            if(row["仙佛"]) text += row["仙佛"];
            if(row["班期"]) text += `${fixedMiddleText}${row["班期"]}`;
            deityCourseLineText = text;
        }

        // 1.1. 計算最大的字元數 (N_chars)
        const dateLen = dateLineText.length;
        const deityCourseLen = deityCourseLineText.length;
        const N_chars = Math.max(dateLen, deityCourseLen);
        
        // 1.2. 實作動態字體大小公式並應用限制
        const dynamicHeaderFontSize = calculateDynamicHeaderFontSize(N_chars);
        const sizeToUseForHeader = dynamicHeaderFontSize;

        // 1.3. 計算視覺對齊的目標長度
        const finalMaxLen = Math.max(dateLen, deityCourseLen);
        const targetLen = finalMaxLen > 1 ? finalMaxLen : ALIGN_MIN_TARGET_LEN;

        // 1.4. 設定字體大小並生成 HTML
        headerBlock.style.fontSize = `${sizeToUseForHeader}px`; 

        let headerContentString = "\n"; 
        // 標題行使用動態計算的字體大小，並透過 inline style 強制覆蓋
        headerContentString += generateAlignedSpan(dateLineText, targetLen, sizeToUseForHeader) + '\n';
        headerContentString += generateAlignedSpan(deityCourseLineText, targetLen, sizeToUseForHeader) + '\n';
        
        headerBlock.innerHTML = headerContentString;
        itemDiv.appendChild(headerBlock);
        // --- 標題文字處理結束 ---


        // --- 2. 主要內容區塊處理 (動態字體，獨立位置) ---
        /* 主要文字內容區塊 (動態字體大小) */
        const contentBlock = document.createElement("div");
        contentBlock.className = "content-block main-content-block"; 
        // 動態設定字體大小 (影響主內容)
        contentBlock.style.fontSize = `${currentFontSize}px`;

        const name = row["姓名"] || "";
        const content = row["內容"] || ""; 
        
        // 2.1. 計算前綴和縮排字串
        const dynamicTotalIndent = name.length + 3; 
        const nameAndSeparatorLength = name.length + 1; // 姓名長度 + 分隔符號 "|" 的長度
        const requiredPrefixSpaces = Math.max(0, dynamicTotalIndent - nameAndSeparatorLength);
        const indentString = "　".repeat(requiredPrefixSpaces); // 全形空格
        const namePrefix = name ? `${indentString}${name}|` : "";

        // 後續行縮排的全形空格字串，長度等於 namePrefix
        const contentIndentLength = namePrefix.length; 
        const contentIndentString = "　".repeat(contentIndentLength); 

        // 2.2. 計算每行可以容納的字元數 (Vertical Line Length Calculation)
        // 1280px total - 50px combined margin
        const MAX_CHARS_HEIGHT = 1230; 
        // 字元佔用像素 (用於字元數計算)
        const CHAR_UNIT_PX = currentFontSize + BASE_LETTER_SPACING_PX; 
        
        // 【修正應用】減去 1 個字元的空間作為安全邊距，防止溢出
        const MAX_CHARS_PER_ROW = Math.floor(MAX_CHARS_HEIGHT / CHAR_UNIT_PX) ;

        // 可用字元數：第一行（在 namePrefix 之後）
        const AVAILABLE_CHARS_FIRST = Math.max(0, MAX_CHARS_PER_ROW - namePrefix.length); 
        // 可用字元數：後續行（在 contentIndentString 之後）
        const AVAILABLE_CHARS_INDENTED = Math.max(0, MAX_CHARS_PER_ROW - contentIndentLength); 

        if (AVAILABLE_CHARS_INDENTED <= 0 || AVAILABLE_CHARS_FIRST <= 0) {
             console.warn("Font size is too large for content block size, indentation may fail.");
        }


        // 2.3. 處理內容：手動斷行並應用縮排 (核心修正邏輯)
        let finalContent = "";
        const manualLines = content.split('\n'); // 先依照原始內容的 '\n' 分段

        manualLines.forEach((manualLine, i) => {
            
            if (i === 0) {
                // --- 處理第一段內容（緊接在姓名之後） ---
                if (manualLine.length <= AVAILABLE_CHARS_FIRST) {
                    // 內容短，一行就夠
                    finalContent += namePrefix + manualLine;
                } else {
                    // 內容長，需要自動換行
                    
                    // Segment 1: 第一行（接在 namePrefix 之後）
                    const firstSegment = manualLine.substring(0, AVAILABLE_CHARS_FIRST);
                    finalContent += namePrefix + firstSegment;
                    
                    // 剩下的內容
                    const remaining = manualLine.substring(AVAILABLE_CHARS_FIRST);
                    
                    // Segment 2+: 剩下的內容進行自動換行分割，並在每段前加上縮排
                    const indentedSegments = segmentLine(remaining, AVAILABLE_CHARS_INDENTED);
                    indentedSegments.forEach(segment => {
                        finalContent += '\n' + contentIndentString + segment;
                    });
                }
            } else {
                // --- 處理後續手動分段的內容（必須完全縮排） ---
                
                // 整個手動分段內容進行自動換行分割，並在每段前加上縮排
                const indentedSegments = segmentLine(manualLine, AVAILABLE_CHARS_INDENTED);
                indentedSegments.forEach(segment => {
                    // 每一段自動換行的內容，都要先插入一個手動換行符號 \n
                    // 確保它在不同的行開始，並且前面帶有縮排
                    finalContent += '\n' + contentIndentString + segment;
                });
            }
        });

        
         // ★ 3. 處理區域文字與 10px 緩衝區的像素計算邏輯 (關鍵修正區塊) ★
        let mainContentHTML = finalContent;
        const area = row["區域"];

        if(area){
            // 像素計算所需常數
            // 主內容字元單位像素 (動態字體 + 基礎間距 13px)
            const CHAR_UNIT_MAIN_PX = currentFontSize + BASE_LETTER_SPACING_PX; 
            // 區域文字字元單位像素 (固定 20px 字體 + 基礎間距 13px)
            const CHAR_UNIT_SMALL_PX = 20 + BASE_LETTER_SPACING_PX;
            const PIXEL_BUFFER = 0; // 用戶指定的 10px 緩衝區

            const areaTextRaw = `（${area}）`; // e.g., （台北）
            const areaTextHtml = `<span class="small-text">${areaTextRaw}</span>`;
            
            // 取得最後一行內容（已包含縮排）
            const finalContentLines = finalContent.split('\n');
            const lastLine = finalContentLines[finalContentLines.length - 1];
            
            // 移除最後一行可能存在的尾部空白 (如果有)
            const trimmedLastLine = lastLine.trimEnd();

            // --- 像素計算核心 ---
            // 1. 最後一行已佔用像素 (使用主內容單位)
            const currentCharactersOnLastLine = trimmedLastLine.length; 
            const pixelsUsedOnLastLine = currentCharactersOnLastLine * CHAR_UNIT_MAIN_PX;

            // 2. 放入新內容所需的像素空間 (包含 10px 緩衝)
            const PIXELS_REQUIRED_FOR_NEW_CONTENT = 
                (1 * CHAR_UNIT_MAIN_PX) +               // 1 個全形空格（作為分隔符，必須佔用主內容單位）
                (areaTextRaw.length * CHAR_UNIT_SMALL_PX) + // 區域文字佔用的像素 (長度 * 小字體單位)
                PIXEL_BUFFER;                           // 10px 緩衝區

            // 3. 檢查總長度是否超過最大高度 (1230px)
            if (pixelsUsedOnLastLine + PIXELS_REQUIRED_FOR_NEW_CONTENT <= MAX_CHARS_HEIGHT) {
                // 【空間足夠】: 移除原始內容的尾部空白，並接上一個分隔空格
                
                // 找到原 finalContent 中最後一行開始的位置
                const lastLineStartIndex = finalContent.lastIndexOf(lastLine);
                // 重新組合內容：(舊內容 - 最後一行) + (最後一行去尾巴)
                const contentWithoutTrailingSpaces = finalContent.substring(0, lastLineStartIndex) + trimmedLastLine;
                
                // 輸出時，附加【一個】全形空格作為視覺間隔
                mainContentHTML = contentWithoutTrailingSpaces + "" + areaTextHtml; 
            } else {
                // 空間不足：強制換行
                const indentStringForArea = "　".repeat(contentIndentLength); // 使用內容的標準縮排
                mainContentHTML += '\n' + indentStringForArea + areaTextHtml; 
            }
        }
        
        contentBlock.innerHTML = mainContentHTML;
        itemDiv.appendChild(contentBlock);
        // --- 主要內容文字處理結束 ---


        /* 單一下載按鈕 */
        const btnWrapper = document.createElement("div");
        btnWrapper.className="download-button-wrapper";
        const btn=document.createElement("button");
        btn.className="btn-style";
        btn.textContent="下載 PNG";

        const filename=`${row["姓名"]||"未知"}-${row["區域"]||"未知"}`;
        btn.onclick=()=>generateImage(itemDiv, filename);

        btnWrapper.appendChild(btn);
        itemDiv.appendChild(btnWrapper);

        resultsContainer.appendChild(itemDiv);
        downloadableItems.push({element:itemDiv, filename});
    });
}

/**
 * 截圖並下載單個圖片 (用於單一按鈕)
 */
async function generateImage(element, filename, callback=()=>{}){
    const hideBtn = element.querySelector('.download-button-wrapper');
    if(hideBtn) hideBtn.style.display='none';

    try {
        // ★ iOS 修復：調整截圖參數 ★
        const options = {
            quality: 0.95,
            // 強制使用 CORS，即使是 Base64 也沒壞處
            useCORS: true, 
            // 重要的 iOS 修復：關閉 allowTaint。如果開啟，iOS Safari 常因為安全理由拒絕導出 Blob
            allowTaint: false, 
            backgroundColor: '#ffffff',
            // 增加 cacheBust 可以解決部分圖片刷新問題
            cacheBust: true,
            // 在某些高解析度 iPhone 上，限制 pixelRatio 可以避免記憶體溢出，預設是 devicePixelRatio
            pixelRatio: window.devicePixelRatio || 1
        };

        const blob = await htmlToImage.toBlob(element, options);
        
        if (blob) {
            saveAs(blob, filename + ".png");
        } else {
            throw new Error('無法生成圖片 Blob');
        }
        
        callback();
    } catch(e){
        console.error("生成圖片失敗:", e);
        displayMessage(`生成圖片失敗: ${e.message}`, true); 
        callback();
    } finally {
        if(hideBtn) hideBtn.style.display='block';
    }
}

/**
 * 下載所有生成的圖片，並將其打包成 ZIP 檔案
 */
async function downloadAllImages(){
    if(downloadableItems.length===0) return;

    downloadAllBtn.disabled=true;
    displayMessage("開始打包 ZIP 檔案，請稍候...");

    const zip = new JSZip();
    const folder = zip.folder("generated_images"); 
    const delay = ms => new Promise(r=>setTimeout(r, ms));

    try {
        for(let i=0;i<downloadableItems.length;i++){
            const item = downloadableItems[i];
            const hideBtn = item.element.querySelector('.download-button-wrapper');
            if(hideBtn) hideBtn.style.display='none';

            displayMessage(`處理中：${item.filename}.png (${i+1}/${downloadableItems.length})`);
            
            // ★ iOS 修復：同步更新下載全部的選項 ★
            const options = {
                quality: 0.95,
                useCORS: true,
                allowTaint: false, // 修正：不要使用 allowTaint
                backgroundColor: '#ffffff',
                cacheBust: true,
                pixelRatio: window.devicePixelRatio || 1
            };

            const imageBlob = await htmlToImage.toBlob(item.element, options);
            folder.file(`${item.filename}.png`, imageBlob);

            if(hideBtn) hideBtn.style.display='block';
            await delay(500); 
        }

        displayMessage("正在壓縮檔案...");
        const zipBlob = await zip.generateAsync({type: "blob"});
        saveAs(zipBlob, "試算表圖檔輸出.zip");
        displayMessage("ZIP 檔案下載完成！");
    } catch(e) {
        console.error("生成 ZIP 失敗:", e);
        displayMessage(`生成 ZIP 失敗: ${e.message}`, true);
    } finally {
        downloadAllBtn.disabled=false;
    }
}
</script>
</body>
</html>
